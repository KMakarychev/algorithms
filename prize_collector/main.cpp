////////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE
//
// To compile with **clang++** or **g++** type:
//   clang++ -std=c++20 -pedantic -Wall main.cpp prize_collector.cpp -o prize_collector.out
//   g++     -std=c++20 -pedantic -Wall main.cpp prize_collector.cpp -o prize_collector.out

#include <string>
#include <vector>
#include <iostream>
#include <cmath>

#include "prize_collector.h"
#include "../common/concise.h"
#include "../common/test_framework.h"

const char *inputFilename = "data/problem_set.in";

constexpr int kTestFrameworkVersion = 110;
constexpr int problem_set_id = 100600;

struct PrizeCollector : public TestFramework::BasicProblem
{
    std::vector<int> prizes;
};

////////////////////////////////////////////////////////////////////////////
// Helper: create an n x n array
////////////////////////////////////////////////////////////////////////////

std::vector<std::vector<int>> BuildPrizeBoard(const std::vector<int>& prizes)
{
    const std::size_t total = prizes.size();
    const std::size_t n = static_cast<std::size_t>(std::sqrt(total));

    std::vector<std::vector<int>> prize_board = alg::create_table(n, n, -1);

    for (std::size_t i = 0; i < n; ++i)
    {
        for (std::size_t j = 0; j < n; ++j)
        {
            prize_board[i][j] = prizes[i * n + j];
        }
    }

    return prize_board;
}

////////////////////////////////////////////////////////////////////////////
// Verifies that all problems have valid input
////////////////////////////////////////////////////////////////////////////

void VerifyInput(const std::vector<PrizeCollector> &problems)
{
    for (const auto &problem : problems)
    {
        const auto& prizes = problem.prizes;

        const std::size_t total = prizes.size();
        const std::size_t n = static_cast<std::size_t>(std::sqrt(total));

        TestFramework::ThrowIfConditionFails(
            n * n == total,
            "Invalid input: number of prizes is not a perfect square."
        );

        for (int prize : prizes)
        {
            TestFramework::ThrowIfConditionFails(
                prize >= 0,
                "Invalid input: prize value must be non-negative."
            );
        }
    }
}

////////////////////////////////////////////////////////////////////////////
// Helper used for student answer computation
////////////////////////////////////////////////////////////////////////////

int RunSolver(const std::vector<int> &prizes)
{
    auto prize_board = BuildPrizeBoard(prizes);
    return FindMaxPrizeCollectingPath(prize_board);
}

////////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{
    using namespace TestFramework;

    static_assert(GetTestFrameworkVersion() == kTestFrameworkVersion,
                  "Incorrect version of Test Framework."
                  "Please, update test_framework.h.");

    ProblemSetHeader header;
    RecordAdapter<ProblemSetHeader> psAdapter(header);
    AddDefaultProblemSetColumns(psAdapter);

    std::vector<PrizeCollector> problems;
    TableAdapter<PrizeCollector> prAdapter(problems);
    AddDefaultProblemColumns(prAdapter);

    AddColumn<PrizeCollector>(prAdapter, "prizes",
                                         &PrizeCollector::prizes);

    BasicYamlParser parser(dynamic_cast<ITable *>(&psAdapter),
                           dynamic_cast<ITable *>(&prAdapter));

    try
    {
        parser.ParseFile(inputFilename, true);
        PreprocessProblemSet(problem_set_id, problems, header);
        VerifyInput(problems);
    }
    catch (const ParseError &e)
    {
        std::cerr << "Parse error. " << e.what() << '\n';
        return 1;
    }
    catch (const TestFrameworkError &e)
    {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }

    for (auto &problem : problems)
    {
        problem.student_answer =
            RunSolver(problem.prizes);
    }

    std::cout << '\n';
    ProcessResults(problems, header);
    std::cout << "Running time: " << header.time << "ms.\n\n";
}
