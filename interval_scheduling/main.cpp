////////////////////////////////////////////////////////////////////////////
// DO NOT EDIT THIS FILE
//
// To compile with **clang++** or **g++** type:
//   clang++ -std=c++20 -pedantic -Wall main.cpp interval_scheduler.cpp -O3 -o scheduler.out
//   g++ -std=c++20 -pedantic -Wall main.cpp interval_scheduler.cpp -O3 -o scheduler.out

#include <string>
#include <vector>
#include <iostream>

#include "interval_scheduler.h"
#include "../common/test_framework.h"

const char *inputFilename = "data/intervals.in";

constexpr int kTestFrameworkVersion = 110;
constexpr int problem_set_id = 1005230;

struct IntervalSchedulingProblem : public TestFramework::BasicProblem
{
    std::vector<int> left;
    std::vector<int> right;
};

////////////////////////////////////////////////////////////////////////////
// Helper: validate input and build jobs
////////////////////////////////////////////////////////////////////////////

std::vector<Job> BuildJobs(const std::vector<int> &left,
                           const std::vector<int> &right)
{
    std::vector<Job> jobs;
    jobs.reserve(left.size());

    for (std::size_t i = 0; i < left.size(); ++i)
    {
        jobs.push_back({left[i], right[i]});
    }

    return jobs;
}

////////////////////////////////////////////////////////////////////////////
// Verifies that all problems have valid input
////////////////////////////////////////////////////////////////////////////

void VerifyInput(const std::vector<IntervalSchedulingProblem> &problems)
{
    for (const auto &problem : problems)
    {
        const std::vector<int> &left = problem.left;
        const std::vector<int> &right = problem.right;

        TestFramework::ThrowIfConditionFails(
            left.size() == right.size(),
            "Invalid data. Arrays of the left and right endpoints have different sizes.");

        std::vector<Job> jobs;
        jobs.reserve(left.size());

        for (std::size_t i = 0; i < left.size(); ++i)
        {
            TestFramework::ThrowIfConditionFails(
                right[i] >= left[i],
                "Left endpoint is greater than the right endpoint. "
                "Please, check the input file.");

            jobs.push_back({left[i], right[i]});
        }
    }
}

////////////////////////////////////////////////////////////////////////////
// Helper used for student answer computation
////////////////////////////////////////////////////////////////////////////

int FindMaxScheduleHelper(const std::vector<int> &left,
                          const std::vector<int> &right)
{
    auto jobs = BuildJobs(left, right);
    return FindMaxSchedule(jobs);
}

////////////////////////////////////////////////////////////////////////////

int main(int argc, char *argv[])
{
    using namespace TestFramework;

    static_assert(GetTestFrameworkVersion() == kTestFrameworkVersion,
                  "Incorrect version of Test Framework."
                  "Please, update test_framework.h.");

    ProblemSetHeader header;
    RecordAdapter<ProblemSetHeader> psAdapter(header);
    AddDefaultProblemSetColumns(psAdapter);

    std::vector<IntervalSchedulingProblem> problems;
    TableAdapter<IntervalSchedulingProblem> prAdapter(problems);
    AddDefaultProblemColumns(prAdapter);

    AddColumn<IntervalSchedulingProblem>(prAdapter, "left",
                                         &IntervalSchedulingProblem::left);

    AddColumn<IntervalSchedulingProblem>(prAdapter, "right",
                                         &IntervalSchedulingProblem::right);

    BasicYamlParser parser(dynamic_cast<ITable *>(&psAdapter),
                           dynamic_cast<ITable *>(&prAdapter));

    try
    {
        parser.ParseFile(inputFilename, true);
        PreprocessProblemSet(problem_set_id, problems, header);
        VerifyInput(problems);
    }
    catch (const ParseError &e)
    {
        std::cerr << "Parse error. " << e.what() << '\n';
        return 1;
    }
    catch (const TestFrameworkError &e)
    {
        std::cerr << "Error: " << e.what() << '\n';
        return 1;
    }

    for (auto &problem : problems)
    {
        problem.student_answer =
            FindMaxScheduleHelper(problem.left, problem.right);
    }

    std::cout << '\n';
    ProcessResults(problems, header);
    std::cout << "Running time: " << header.time << "ms.\n\n";
}
